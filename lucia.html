<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Animated Gradient Noise (Ultra Subtle Scanlines)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0; left: 0;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="bg"></canvas>
<script>
const canvas = document.getElementById("bg");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const baseColor = [5, 10, 16];
const brightColor = [28, 32, 38];
const fadePeriod = 20;

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function animate() {
  const t = (1 - Math.cos(Math.PI * ((performance.now() / 1000) % fadePeriod) / (fadePeriod/2))) / 2;

  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2;
  const gradRadius = Math.max(w,h)*0.8;
  const innerRadius = Math.min(w,h)*0.1;

  // --- Manual radial gradient with reduced dither ---
  const imageData = ctx.createImageData(w, h);
  const d = imageData.data;

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const dx = x - cx, dy = y - cy;
      let r = Math.sqrt(dx*dx + dy*dy);
      let f = (r - innerRadius) / (gradRadius - innerRadius);
      f = Math.max(0, Math.min(1, f));
      f += (Math.random()-0.5) * 0.012; // reduced dither for smoothness
      f = Math.max(0, Math.min(1, f));
      const col1 = baseColor.map((c,i)=>Math.round(lerp(c, brightColor[i], t)));
      const col2 = baseColor.map((c,i)=>Math.round(lerp(brightColor[i], 255, t*0.6)));
      const rC = Math.round(lerp(col1[0], col2[0], f));
      const gC = Math.round(lerp(col1[1], col2[1], f));
      const bC = Math.round(lerp(col1[2], col2[2], f));
      const idx = 4 * (y * w + x);
      d[idx] = rC;
      d[idx+1] = gC;
      d[idx+2] = bC;
      d[idx+3] = 255;
    }
  }

  // --- Noise overlay ---
  const noiseStrength = 10 + t * 32;
  for (let i = 0; i < d.length; i += 4) {
    const x = ((i/4) % w), y = Math.floor((i/4) / w);
    const grain = ((Math.sin(x * 0.22 + y * 0.31 + performance.now()*0.0009) + 1) * 0.5) * noiseStrength;
    d[i]   = Math.min(255, d[i]   + grain);
    d[i+1] = Math.min(255, d[i+1] + grain);
    d[i+2] = Math.min(255, d[i+2] + grain);
  }

  // --- Ultra-faint scanlines (opacity 0.03) ---
  const lineSpacing = 3;
  const lineThickness = 2;
  const opacity = 0.03; // << TRY 0.01 if you want them even fainter!
  const lineR = 255, lineG = 255, lineB = 255; // white scanline

  for (let y = 0; y < h; y++) {
    if ((y % lineSpacing) < lineThickness) {
      for (let x = 0; x < w; x++) {
        const idx = 4 * (y * w + x);
        d[idx]   = Math.round(d[idx]   * (1-opacity) + lineR * opacity);
        d[idx+1] = Math.round(d[idx+1] * (1-opacity) + lineG * opacity);
        d[idx+2] = Math.round(d[idx+2] * (1-opacity) + lineB * opacity);
      }
    }
  }

  ctx.putImageData(imageData, 0, 0);
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
