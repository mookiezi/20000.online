<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lucia â€• Ultra Holo Diagonal (Adjustable)</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #fps { position: fixed; top: 10px; left: 10px; color: #0f0; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
    #controls { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 10px; color:#fff; font-family:sans-serif; font-size:12px; border-radius:8px; }
    #controls label { display:block; margin-bottom:4px; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="fps">FPS: 0</div>
<div id="controls">
  <label>Holo Strength <input id="holoStrength" type="range" min="0" max="0.3" step="0.01" value="0.09"></label>
  <label>Noise Strength <input id="noiseStrength" type="range" min="0" max="0.2" step="0.01" value="0.07"></label>
  <label>Brightness <input id="brightness" type="range" min="0" max="1.5" step="0.01" value="1"></label>
  <label>Speed <input id="speed" type="range" min="0" max="3" step="0.01" value="1"></label>
</div>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);

window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
});

const vertexShaderSource = `
attribute vec2 a_position;
void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
`;

const fragmentShaderSource = `
precision highp float;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_holoStrength;
uniform float u_noiseStrength;
uniform float u_brightness;
uniform float u_speed;

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

vec3 hsv2rgb(vec3 c) {
  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0,4,2),6.0)-3.0)-1.0,0.0,1.0);
  rgb = rgb*rgb*(3.0-2.0*rgb);
  return c.z * mix(vec3(1.0), rgb, c.y);
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  vec2 center = vec2(0.5,0.5);
  vec2 pos = uv-center;
  float r = length(pos)*2.0;

  float t = (1.0-cos(3.1415*mod(u_time*u_speed,20.0)/10.0))*0.35;

  vec3 baseColor = mix(vec3(10,14,18)/255.0, vec3(18,22,28)/255.0, t);
  vec3 brightColor = mix(baseColor, vec3(1.0), t*0.6);
  vec3 color = mix(baseColor, brightColor, smoothstep(0.1,0.8,r));

  // noise
  float grain = ((sin(uv.x*22.0 + uv.y*31.0 + u_time*0.9*u_speed)+1.0)*0.5) * (0.07 + t*0.16);
  color += grain * u_noiseStrength;

  // holo hue shift
  float holoHue = mod(210.0 + 90.0*sin(u_time*0.00325*300.0*u_speed + (uv.x-uv.y)*8.0), 360.0)/360.0;
  vec3 holo = hsv2rgb(vec3(holoHue, 0.10, 0.87));
  color = mix(color, holo, u_holoStrength);

  // big horizontal scanlines
  float bigLine = step(0.0, mod(gl_FragCoord.y, 3.0) - 2.0);
  color = mix(color, vec3(1.0), (1.0-bigLine)*0.012);

  // extra CRT fine scanlines
  float fineScan = 0.5 + 0.5*sin(gl_FragCoord.y*3.1415);
  color *= mix(0.95, 1.05, fineScan);

  // BIG diagonal stripes (like 1st image)
  float diagBig = step(0.45, fract((gl_FragCoord.x + gl_FragCoord.y)*0.03));
  color = mix(color, holo, (1.0-diagBig)*0.08);

  // SMALL diagonal stripes
  float diagSmall = step(0.5, fract((gl_FragCoord.x + gl_FragCoord.y)*0.12));
  color = mix(color, holo, (1.0-diagSmall)*0.05);

  gl_FragColor = vec4(color * u_brightness, 1.0);
}
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(shader));
  return shader;
}
function createProgram(gl, vShader, fShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    console.error(gl.getProgramInfoLog(program));
  return program;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);

const posLoc = gl.getAttribLocation(program, "a_position");
const resLoc = gl.getUniformLocation(program, "u_resolution");
const timeLoc = gl.getUniformLocation(program, "u_time");
const holoLoc = gl.getUniformLocation(program, "u_holoStrength");
const noiseLoc = gl.getUniformLocation(program, "u_noiseStrength");
const brightLoc = gl.getUniformLocation(program, "u_brightness");
const speedLoc = gl.getUniformLocation(program, "u_speed");

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

gl.useProgram(program);
gl.enableVertexAttribArray(posLoc);
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

let fpsElem = document.getElementById("fps");
let last = performance.now(), frames = 0;

function render(time) {
  frames++;
  if (time - last >= 1000) {
    fpsElem.textContent = "FPS: " + frames;
    frames = 0;
    last = time;
  }

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, time*0.001);
  gl.uniform1f(holoLoc, parseFloat(holoStrength.value));
  gl.uniform1f(noiseLoc, parseFloat(noiseStrength.value));
  gl.uniform1f(brightLoc, parseFloat(brightness.value));
  gl.uniform1f(speedLoc, parseFloat(speed.value));
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
