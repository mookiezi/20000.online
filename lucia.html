<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lucia â€• Ultra Holo Diagonal (Original Scale Default)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      background: rgba(0,0,0,0.85);
      padding: 12px 0;
      color: #fff;
      border-radius: 0;
    }
    #controls label {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: monospace;
      font-weight: bold;
      font-size: 14px;
    }
    #controls label span {
      margin-bottom: 10px; /* moves the text up above the slider */
    }
    #scaleValue {
      font-family: monospace;
      font-weight: bold;
      font-size: 14px;
      align-self: center;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<div id="controls">
  <label><span>Holo</span><input id="holoStrength" type="range" min="0" max="0.3" step="0.01" value="0.09"></label>
  <label><span>Noise</span><input id="noiseStrength" type="range" min="0" max="0.2" step="0.01" value="0.07"></label>
  <label><span>Bright</span><input id="brightness" type="range" min="0" max="1.5" step="0.01" value="1"></label>
  <label><span>Speed</span><input id="speed" type="range" min="0" max="3" step="0.01" value="1"></label>
  <label><span>Scale</span><input id="scaleSlider" type="range" min="0.75" max="3.0" step="0.05" value="3.0"></label>
  <span id="scaleValue">Scale: 3.00</span>
</div>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

let scaleFactor = 3.0; // Default to original size

function resizeCanvas() {
  canvas.width = Math.floor(window.innerWidth * (scaleFactor / 3.0));
  canvas.height = Math.floor(window.innerHeight * (scaleFactor / 3.0));
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

const scaleSlider = document.getElementById("scaleSlider");
const scaleValue = document.getElementById("scaleValue");

scaleSlider.addEventListener("input", (e) => {
  scaleFactor = parseFloat(e.target.value);
  scaleValue.textContent = "Scale: " + scaleFactor.toFixed(2);
  resizeCanvas();
});

const vertexShaderSource = `
attribute vec2 a_position;
void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
`;

const fragmentShaderSource = `
precision highp float;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_holoStrength;
uniform float u_noiseStrength;
uniform float u_brightness;
uniform float u_speed;

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}
vec3 hsv2rgb(vec3 c) {
  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0,4,2),6.0)-3.0)-1.0,0.0,1.0);
  rgb = rgb*rgb*(3.0-2.0*rgb);
  return c.z * mix(vec3(1.0), rgb, c.y);
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  vec2 center = vec2(0.5,0.5);
  vec2 pos = uv-center;
  float r = length(pos)*2.0;

  float t = 0.35 * (0.5 + 0.5*sin(u_time * 0.2 * u_speed));

  vec3 baseColor = mix(vec3(10,14,18)/255.0, vec3(18,22,28)/255.0, t);
  vec3 brightColor = mix(baseColor, vec3(1.0), t*0.6);
  vec3 color = mix(baseColor, brightColor, smoothstep(0.1,0.8,r));

  float grain = ((sin(uv.x*22.0 + uv.y*31.0 + u_time*0.9*u_speed)+1.0)*0.5) * 0.16;
  color += grain * u_noiseStrength;

  float holoHue = mod(210.0 + 90.0*sin(u_time*0.00325*300.0*u_speed + (uv.x-uv.y)*8.0), 360.0)/360.0;
  vec3 holo = hsv2rgb(vec3(holoHue, 0.10, 0.87));
  color = mix(color, holo, u_holoStrength);

  float bigLine = step(0.0, mod(gl_FragCoord.y, 3.0) - 2.0);
  color = mix(color, vec3(1.0), (1.0-bigLine)*0.012);

  float fineScan = 0.5 + 0.5*sin(gl_FragCoord.y*3.1415);
  color *= mix(0.95, 1.05, fineScan);

  float diagBig = step(0.45, fract((gl_FragCoord.x + gl_FragCoord.y)*0.03));
  color = mix(color, holo, (1.0-diagBig)*0.08);

  float diagSmall = step(0.5, fract((gl_FragCoord.x + gl_FragCoord.y)*0.12));
  color = mix(color, holo, (1.0-diagSmall)*0.05);

  gl_FragColor = vec4(color * u_brightness, 1.0);
}
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function createProgram(gl, vShader, fShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  return program;
}

const vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vShader, fShader);

const posLoc = gl.getAttribLocation(program, "a_position");
const resLoc = gl.getUniformLocation(program, "u_resolution");
const timeLoc = gl.getUniformLocation(program, "u_time");
const holoLoc = gl.getUniformLocation(program, "u_holoStrength");
const noiseLoc = gl.getUniformLocation(program, "u_noiseStrength");
const brightLoc = gl.getUniformLocation(program, "u_brightness");
const speedLoc = gl.getUniformLocation(program, "u_speed");

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

gl.useProgram(program);
gl.enableVertexAttribArray(posLoc);
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

function render(time) {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, time*0.001);
  gl.uniform1f(holoLoc, parseFloat(holoStrength.value));
  gl.uniform1f(noiseLoc, parseFloat(noiseStrength.value));
  gl.uniform1f(brightLoc, parseFloat(brightness.value));
  gl.uniform1f(speedLoc, parseFloat(speed.value));
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
